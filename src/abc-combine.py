#! /usr/bin/python

# combine all the .bin files back into an .abc file
#
# input is a json file output by abc-parse
# output is a new abc file

import argparse
import json
import sys
import subprocess
import os
from typing import Any, Optional

parser = argparse.ArgumentParser(
    prog="abc-combine",
    description="Combine components back into an Alembic .abc file",
    epilog="Use abc-parse to generate the json file and abc-separate to generate the bin files.",
)

parser.add_argument(
    "json",
    help="Path to a json file that describes the alembic file (generated by abc-parse)",
)
parser.add_argument(
    "output",
    help="Path to the output .abc file; must not be the .abc file named by the json",
)
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument(
    "--override",
    nargs=2,
    action="append",
    help="Override a property with a different binary file",
)


class Replacement:
    def __init__(self, path, binfile):
        self.path = path
        self.binfile = binfile


def check_component(
    component: dict[str, Any], overrides: dict[str, str], verbose: bool
) -> Optional[Replacement]:
    path = component["path"]
    binfile = component["bin"]

    # Overrides can name either the property path or the default filename, but
    # always map to the override filename.
    if path in overrides:
        binfile = overrides[path]
    elif binfile in overrides:
        binfile = overrides[binfile]

    if not os.path.exists(binfile):
        if verbose:
            print(f"Not replacing component {path} (no file {binfile})")
        return None
    if verbose:
        print(f"Replacing {path} with {binfile}")
    return Replacement(path, binfile)


def combine(
    abcfile: str, outfile: str, replacements: list[Replacement], verbose: bool
) -> bool:
    exepath = os.path.dirname(__file__) + "/abc-combine"
    args = [exepath]
    if verbose:
        args.append("-v")
    args.append(abcfile)
    args.extend(("-o", outfile))
    for replacement in replacements:
        args.extend(("-p", replacement.path, replacement.binfile))
    if verbose:
        print("Running " + " ".join(args))
    result = subprocess.run(args)
    return result.returncode == 0


def main(
    jsonfile: str, outfile: str, verbose: bool, overrides: list[list[str]]
) -> bool:
    def make_override(override: list[str]) -> tuple[str, str]:
        # raises IndexError if the list isn't at least a pair.
        return (override[0], override[1])

    over = {path: binfile for path, binfile in map(make_override, overrides)}

    with open(jsonfile) as f:
        metadata = json.load(f)

    try:
        abcfile = metadata["abc"]
        if not isinstance(abcfile, str):
            raise TypeError
    except:
        print(f"alembic file not specified in {jsonfile}")
        return False

    try:
        components = metadata["components"]
        if not isinstance(components, list):
            raise TypeError
    except:
        print(f"no components listed in {jsonfile}")
        return False

    # From now on, we blindly assume that the components follow the schema.
    replacements = []
    for component in components:
        checked = check_component(component, over, verbose)
        if checked is not None:
            replacements.append(checked)

    combine(abcfile, outfile, replacements, verbose)
    return True


if __name__ == "__main__":
    args = parser.parse_args()
    ok = main(args.json, args.output, args.verbose, args.override)
    if ok:
        sys.exit(0)
    else:
        sys.exit(1)
